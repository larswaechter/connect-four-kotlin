/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package connect.four

import io.javalin.Javalin
import io.javalin.websocket.WsMessageContext

class App {
    private val games: HashMap<String, ConnectFour> = hashMapOf()
    private val gameLobbies: HashMap<String, GameLobby> = hashMapOf()

    init {
        val app = Javalin.create { config ->
            config.addStaticFiles("/public")
        }.start(7070)

        app.get("/start/:id") { ctx ->
            val id = ctx.pathParam("id")
            val players = ctx.queryParam("players")!!.toInt()
            val difficulty = ctx.queryParam("difficulty")!!.toInt()

            val newGame = ConnectFour(difficulty = difficulty, multiplayer = players == 2)

            games[id] = newGame
            ctx.html(newGame.toHTML())
        }

        app.get("/:id/move/:column") { ctx ->
            val paramID = ctx.pathParam("id")
            val paramColumn = ctx.pathParam("column")

            // Validate parameter
            if (games.containsKey(paramID) && paramColumn.matches(Regex("^[0-6]\$"))) {
                var game = games[paramID]!!
                val column = paramColumn.toInt()
                game = game.move(Move(column))

                if (!game.multiplayer) game = game.move(game.getRandomMove())

                games[paramID] = game

                if (game.hasWinner()) {
                    games.remove(paramID)
                    ctx.html(game.toHTML())
                } else if (game.getNumberOfRemainingMoves() == 0) {
                    games.remove(paramID)
                    ctx.html(game.toHTML())
                } else {
                    ctx.html(game.toHTML())
                }
            }
        }

        app.ws("/ws/create/:id") { ws ->
            ws.onConnect { ctx ->
                val id = ctx.pathParam("id")

                if (id.matches(Regex("[a-z]{16}"))) {
                    val newGame = GameLobby(ctx, null, ctx.sessionId)
                    gameLobbies[id] = newGame
                    ctx.send("<p class='text-center'>Waiting for another player...</p>")
                } else {
                    ctx.send("Invalid session id")
                }
            }
            ws.onMessage() { ctx -> this.handleWebsocketMessage(ctx) }
        }

        app.ws("/ws/join/:id") { ws ->
            ws.onConnect { ctx ->
                val id = ctx.pathParam("id")

                if (id.matches(Regex("[a-z]{16}")) && gameLobbies.containsKey(id)) {
                    val game = gameLobbies[id]!!
                    game.playerTwoSocket = ctx
                    gameLobbies[id] = game

                    game.playerOneSocket!!.send(game.game.toHTML())
                    game.playerTwoSocket!!.send(game.game.toHTML())
                } else {
                    ctx.send("Lobby not found!")
                }
            }

            ws.onMessage() { ctx -> this.handleWebsocketMessage(ctx) }
        }
    }

    private fun handleWebsocketMessage(ctx: WsMessageContext) {
        val id = ctx.pathParam("id")!!
        val column = ctx.message()

        if (id.matches(Regex("[a-z]{16}")) && gameLobbies.containsKey(id) && column.matches(Regex("^[0-6]\$"))) {
            val lobby = gameLobbies[id]!!

            if (ctx.sessionId == lobby.currentPlayerSessionID) {
                lobby.game = lobby.game.move(Move(column.toInt()))
                lobby.currentPlayerSessionID = when (lobby.currentPlayerSessionID) {
                    lobby.playerOneSocket!!.sessionId -> lobby.playerTwoSocket!!.sessionId
                    else -> lobby.playerOneSocket!!.sessionId
                }
                gameLobbies[id] = lobby
            }

            lobby.playerOneSocket!!.send(lobby.game.toHTML())
            lobby.playerTwoSocket!!.send(lobby.game.toHTML())
        } else {
            ctx.send("Invalid request!")
        }
    }
}


fun main() {

    App()

    // train()


    // Minimax.Storage.seedByMovesPlayed(2000, 40)
    // Minimax.Storage.seedByMovesPlayed(2000, 40)


    // println(ConnectFour(difficulty = 42).bestMove())

    /*

    val start = System.currentTimeMillis()

    val game = ConnectFour.playRandomMoves(1)
    println(game.bestMove())
    println((System.currentTimeMillis() - start) / 1000)

     */


}

fun train() {
    for (i in 3 downTo 1) {
        for (k in 1..3) Minimax.Storage.seedByMovesPlayed(2500, i)
    }
}

fun playGame() {
    var game = ConnectFour(difficulty = 4)

    while (!game.isGameOver()) {
        println(game)
        print("Enter move: ")

        val move = Move(readLine()!!.toInt())
        game = game.move(move)

        if (game.isGameOver()) break
        game = game.bestMove()
    }

    println(game)
}